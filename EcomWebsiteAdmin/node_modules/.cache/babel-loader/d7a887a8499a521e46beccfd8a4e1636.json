{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport * as React from 'react';\nimport { ScriptLoader } from '../ScriptLoader2';\nimport { getTinymce } from '../TinyMCE';\nimport { isFunction, isTextareaOrInput, mergePlugins, uuid, configHandlers, isBeforeInputEventAvailable, isInDoc, setMode } from '../Utils';\nimport { EditorPropTypes } from './EditorPropTypes';\n/**\n * @see {@link https://www.tiny.cloud/docs/tinymce/7/react-ref/} for the TinyMCE React Technical Reference\n */\nvar Editor = /** @class */function (_super) {\n  __extends(Editor, _super);\n  function Editor(props) {\n    var _a, _b, _c;\n    var _this = _super.call(this, props) || this;\n    _this.rollbackTimer = undefined;\n    _this.valueCursor = undefined;\n    _this.rollbackChange = function () {\n      var editor = _this.editor;\n      var value = _this.props.value;\n      if (editor && value && value !== _this.currentContent) {\n        editor.undoManager.ignore(function () {\n          editor.setContent(value);\n          // only restore cursor on inline editors when they are focused\n          // as otherwise it will cause a focus grab\n          if (_this.valueCursor && (!_this.inline || editor.hasFocus())) {\n            try {\n              editor.selection.moveToBookmark(_this.valueCursor);\n            } catch (e) {/* ignore */}\n          }\n        });\n      }\n      _this.rollbackTimer = undefined;\n    };\n    _this.handleBeforeInput = function (_evt) {\n      if (_this.props.value !== undefined && _this.props.value === _this.currentContent && _this.editor) {\n        if (!_this.inline || _this.editor.hasFocus()) {\n          try {\n            // getBookmark throws exceptions when the editor has not been focused\n            // possibly only in inline mode but I'm not taking chances\n            _this.valueCursor = _this.editor.selection.getBookmark(3);\n          } catch (e) {/* ignore */}\n        }\n      }\n    };\n    _this.handleBeforeInputSpecial = function (evt) {\n      if (evt.key === 'Enter' || evt.key === 'Backspace' || evt.key === 'Delete') {\n        _this.handleBeforeInput(evt);\n      }\n    };\n    _this.handleEditorChange = function (_evt) {\n      var editor = _this.editor;\n      if (editor && editor.initialized) {\n        var newContent = editor.getContent();\n        if (_this.props.value !== undefined && _this.props.value !== newContent && _this.props.rollback !== false) {\n          // start a timer and revert to the value if not applied in time\n          if (!_this.rollbackTimer) {\n            _this.rollbackTimer = window.setTimeout(_this.rollbackChange, typeof _this.props.rollback === 'number' ? _this.props.rollback : 200);\n          }\n        }\n        if (newContent !== _this.currentContent) {\n          _this.currentContent = newContent;\n          if (isFunction(_this.props.onEditorChange)) {\n            _this.props.onEditorChange(newContent, editor);\n          }\n        }\n      }\n    };\n    _this.handleEditorChangeSpecial = function (evt) {\n      if (evt.key === 'Backspace' || evt.key === 'Delete') {\n        _this.handleEditorChange(evt);\n      }\n    };\n    _this.initialise = function (attempts) {\n      var _a, _b, _c;\n      if (attempts === void 0) {\n        attempts = 0;\n      }\n      var target = _this.elementRef.current;\n      if (!target) {\n        return; // Editor has been unmounted\n      }\n      if (!isInDoc(target)) {\n        // this is probably someone trying to help by rendering us offscreen\n        // but we can't do that because the editor iframe must be in the document\n        // in order to have state\n        if (attempts === 0) {\n          // we probably just need to wait for the current events to be processed\n          setTimeout(function () {\n            return _this.initialise(1);\n          }, 1);\n        } else if (attempts < 100) {\n          // wait for ten seconds, polling every tenth of a second\n          setTimeout(function () {\n            return _this.initialise(attempts + 1);\n          }, 100);\n        } else {\n          // give up, at this point it seems that more polling is unlikely to help\n          throw new Error('tinymce can only be initialised when in a document');\n        }\n        return;\n      }\n      var tinymce = getTinymce(_this.view);\n      if (!tinymce) {\n        throw new Error('tinymce should have been loaded into global scope');\n      }\n      var finalInit = __assign(__assign(__assign(__assign({}, _this.props.init), {\n        selector: undefined,\n        target: target,\n        readonly: _this.props.disabled,\n        inline: _this.inline,\n        plugins: mergePlugins((_a = _this.props.init) === null || _a === void 0 ? void 0 : _a.plugins, _this.props.plugins),\n        toolbar: (_b = _this.props.toolbar) !== null && _b !== void 0 ? _b : (_c = _this.props.init) === null || _c === void 0 ? void 0 : _c.toolbar\n      }), _this.props.licenseKey ? {\n        license_key: _this.props.licenseKey\n      } : {}), {\n        setup: function (editor) {\n          _this.editor = editor;\n          _this.bindHandlers({});\n          // When running in inline mode the editor gets the initial value\n          // from the innerHTML of the element it is initialized on.\n          // However we don't want to take on the responsibility of sanitizing\n          // to remove XSS in the react integration so we have a chicken and egg\n          // problem... We avoid it by sneaking in a set content before the first\n          // \"official\" setContent and using TinyMCE to do the sanitization.\n          if (_this.inline && !isTextareaOrInput(target)) {\n            editor.once('PostRender', function (_evt) {\n              editor.setContent(_this.getInitialValue(), {\n                no_events: true\n              });\n            });\n          }\n          if (_this.props.init && isFunction(_this.props.init.setup)) {\n            _this.props.init.setup(editor);\n          }\n        },\n        init_instance_callback: function (editor) {\n          var _a, _b;\n          // check for changes that happened since tinymce.init() was called\n          var initialValue = _this.getInitialValue();\n          _this.currentContent = (_a = _this.currentContent) !== null && _a !== void 0 ? _a : editor.getContent();\n          if (_this.currentContent !== initialValue) {\n            _this.currentContent = initialValue;\n            // same as resetContent in TinyMCE 5\n            editor.setContent(initialValue);\n            editor.undoManager.clear();\n            editor.undoManager.add();\n            editor.setDirty(false);\n          }\n          var disabled = (_b = _this.props.disabled) !== null && _b !== void 0 ? _b : false;\n          setMode(_this.editor, disabled ? 'readonly' : 'design');\n          // ensure existing init_instance_callback is called\n          if (_this.props.init && isFunction(_this.props.init.init_instance_callback)) {\n            _this.props.init.init_instance_callback(editor);\n          }\n        }\n      });\n      if (!_this.inline) {\n        target.style.visibility = '';\n      }\n      if (isTextareaOrInput(target)) {\n        target.value = _this.getInitialValue();\n      }\n      tinymce.init(finalInit);\n    };\n    _this.id = _this.props.id || uuid('tiny-react');\n    _this.elementRef = React.createRef();\n    _this.inline = (_c = (_a = _this.props.inline) !== null && _a !== void 0 ? _a : (_b = _this.props.init) === null || _b === void 0 ? void 0 : _b.inline) !== null && _c !== void 0 ? _c : false;\n    _this.boundHandlers = {};\n    return _this;\n  }\n  Object.defineProperty(Editor.prototype, \"view\", {\n    get: function () {\n      var _a, _b;\n      return (_b = (_a = this.elementRef.current) === null || _a === void 0 ? void 0 : _a.ownerDocument.defaultView) !== null && _b !== void 0 ? _b : window;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Editor.prototype.componentDidUpdate = function (prevProps) {\n    var _this = this;\n    var _a, _b;\n    if (this.rollbackTimer) {\n      clearTimeout(this.rollbackTimer);\n      this.rollbackTimer = undefined;\n    }\n    if (this.editor) {\n      this.bindHandlers(prevProps);\n      if (this.editor.initialized) {\n        this.currentContent = (_a = this.currentContent) !== null && _a !== void 0 ? _a : this.editor.getContent();\n        if (typeof this.props.initialValue === 'string' && this.props.initialValue !== prevProps.initialValue) {\n          // same as resetContent in TinyMCE 5\n          this.editor.setContent(this.props.initialValue);\n          this.editor.undoManager.clear();\n          this.editor.undoManager.add();\n          this.editor.setDirty(false);\n        } else if (typeof this.props.value === 'string' && this.props.value !== this.currentContent) {\n          var localEditor_1 = this.editor;\n          localEditor_1.undoManager.transact(function () {\n            // inline editors grab focus when restoring selection\n            // so we don't try to keep their selection unless they are currently focused\n            var cursor;\n            if (!_this.inline || localEditor_1.hasFocus()) {\n              try {\n                // getBookmark throws exceptions when the editor has not been focused\n                // possibly only in inline mode but I'm not taking chances\n                cursor = localEditor_1.selection.getBookmark(3);\n              } catch (e) {/* ignore */}\n            }\n            var valueCursor = _this.valueCursor;\n            localEditor_1.setContent(_this.props.value);\n            if (!_this.inline || localEditor_1.hasFocus()) {\n              for (var _i = 0, _a = [cursor, valueCursor]; _i < _a.length; _i++) {\n                var bookmark = _a[_i];\n                if (bookmark) {\n                  try {\n                    localEditor_1.selection.moveToBookmark(bookmark);\n                    _this.valueCursor = bookmark;\n                    break;\n                  } catch (e) {/* ignore */}\n                }\n              }\n            }\n          });\n        }\n        if (this.props.disabled !== prevProps.disabled) {\n          var disabled = (_b = this.props.disabled) !== null && _b !== void 0 ? _b : false;\n          setMode(this.editor, disabled ? 'readonly' : 'design');\n        }\n      }\n    }\n  };\n  Editor.prototype.componentDidMount = function () {\n    var _this = this;\n    var _a, _b, _c, _d, _e;\n    if (getTinymce(this.view) !== null) {\n      this.initialise();\n    } else if (Array.isArray(this.props.tinymceScriptSrc) && this.props.tinymceScriptSrc.length === 0) {\n      (_b = (_a = this.props).onScriptsLoadError) === null || _b === void 0 ? void 0 : _b.call(_a, new Error('No `tinymce` global is present but the `tinymceScriptSrc` prop was an empty array.'));\n    } else if ((_c = this.elementRef.current) === null || _c === void 0 ? void 0 : _c.ownerDocument) {\n      var successHandler = function () {\n        var _a, _b;\n        (_b = (_a = _this.props).onScriptsLoad) === null || _b === void 0 ? void 0 : _b.call(_a);\n        _this.initialise();\n      };\n      var errorHandler = function (err) {\n        var _a, _b;\n        (_b = (_a = _this.props).onScriptsLoadError) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n      };\n      ScriptLoader.loadList(this.elementRef.current.ownerDocument, this.getScriptSources(), (_e = (_d = this.props.scriptLoading) === null || _d === void 0 ? void 0 : _d.delay) !== null && _e !== void 0 ? _e : 0, successHandler, errorHandler);\n    }\n  };\n  Editor.prototype.componentWillUnmount = function () {\n    var _this = this;\n    var editor = this.editor;\n    if (editor) {\n      editor.off(this.changeEvents(), this.handleEditorChange);\n      editor.off(this.beforeInputEvent(), this.handleBeforeInput);\n      editor.off('keypress', this.handleEditorChangeSpecial);\n      editor.off('keydown', this.handleBeforeInputSpecial);\n      editor.off('NewBlock', this.handleEditorChange);\n      Object.keys(this.boundHandlers).forEach(function (eventName) {\n        editor.off(eventName, _this.boundHandlers[eventName]);\n      });\n      this.boundHandlers = {};\n      editor.remove();\n      this.editor = undefined;\n    }\n  };\n  Editor.prototype.render = function () {\n    return this.inline ? this.renderInline() : this.renderIframe();\n  };\n  Editor.prototype.changeEvents = function () {\n    var _a, _b, _c;\n    var isIE = (_c = (_b = (_a = getTinymce(this.view)) === null || _a === void 0 ? void 0 : _a.Env) === null || _b === void 0 ? void 0 : _b.browser) === null || _c === void 0 ? void 0 : _c.isIE();\n    return isIE ? 'change keyup compositionend setcontent CommentChange' : 'change input compositionend setcontent CommentChange';\n  };\n  Editor.prototype.beforeInputEvent = function () {\n    return isBeforeInputEventAvailable() ? 'beforeinput SelectionChange' : 'SelectionChange';\n  };\n  Editor.prototype.renderInline = function () {\n    var _a = this.props.tagName,\n      tagName = _a === void 0 ? 'div' : _a;\n    return React.createElement(tagName, {\n      ref: this.elementRef,\n      id: this.id,\n      tabIndex: this.props.tabIndex\n    });\n  };\n  Editor.prototype.renderIframe = function () {\n    return React.createElement('textarea', {\n      ref: this.elementRef,\n      style: {\n        visibility: 'hidden'\n      },\n      name: this.props.textareaName,\n      id: this.id,\n      tabIndex: this.props.tabIndex\n    });\n  };\n  Editor.prototype.getScriptSources = function () {\n    var _a, _b;\n    var async = (_a = this.props.scriptLoading) === null || _a === void 0 ? void 0 : _a.async;\n    var defer = (_b = this.props.scriptLoading) === null || _b === void 0 ? void 0 : _b.defer;\n    if (this.props.tinymceScriptSrc !== undefined) {\n      if (typeof this.props.tinymceScriptSrc === 'string') {\n        return [{\n          src: this.props.tinymceScriptSrc,\n          async: async,\n          defer: defer\n        }];\n      }\n      // multiple scripts can be specified which allows for hybrid mode\n      return this.props.tinymceScriptSrc.map(function (item) {\n        if (typeof item === 'string') {\n          // async does not make sense for multiple items unless\n          // they are not dependent (which will be unlikely)\n          return {\n            src: item,\n            async: async,\n            defer: defer\n          };\n        } else {\n          return item;\n        }\n      });\n    }\n    // fallback to the cloud when the tinymceScriptSrc is not specified\n    var channel = this.props.cloudChannel; // `cloudChannel` is in `defaultProps`, so it's always defined.\n    var apiKey = this.props.apiKey ? this.props.apiKey : 'no-api-key';\n    var cloudTinyJs = \"https://cdn.tiny.cloud/1/\".concat(apiKey, \"/tinymce/\").concat(channel, \"/tinymce.min.js\");\n    return [{\n      src: cloudTinyJs,\n      async: async,\n      defer: defer\n    }];\n  };\n  Editor.prototype.getInitialValue = function () {\n    if (typeof this.props.initialValue === 'string') {\n      return this.props.initialValue;\n    } else if (typeof this.props.value === 'string') {\n      return this.props.value;\n    } else {\n      return '';\n    }\n  };\n  Editor.prototype.bindHandlers = function (prevProps) {\n    var _this = this;\n    if (this.editor !== undefined) {\n      // typescript chokes trying to understand the type of the lookup function\n      configHandlers(this.editor, prevProps, this.props, this.boundHandlers, function (key) {\n        return _this.props[key];\n      });\n      // check if we should monitor editor changes\n      var isValueControlled = function (p) {\n        return p.onEditorChange !== undefined || p.value !== undefined;\n      };\n      var wasControlled = isValueControlled(prevProps);\n      var nowControlled = isValueControlled(this.props);\n      if (!wasControlled && nowControlled) {\n        this.editor.on(this.changeEvents(), this.handleEditorChange);\n        this.editor.on(this.beforeInputEvent(), this.handleBeforeInput);\n        this.editor.on('keydown', this.handleBeforeInputSpecial);\n        this.editor.on('keyup', this.handleEditorChangeSpecial);\n        this.editor.on('NewBlock', this.handleEditorChange);\n      } else if (wasControlled && !nowControlled) {\n        this.editor.off(this.changeEvents(), this.handleEditorChange);\n        this.editor.off(this.beforeInputEvent(), this.handleBeforeInput);\n        this.editor.off('keydown', this.handleBeforeInputSpecial);\n        this.editor.off('keyup', this.handleEditorChangeSpecial);\n        this.editor.off('NewBlock', this.handleEditorChange);\n      }\n    }\n  };\n  Editor.propTypes = EditorPropTypes;\n  Editor.defaultProps = {\n    cloudChannel: '7'\n  };\n  return Editor;\n}(React.Component);\nexport { Editor };","map":null,"metadata":{},"sourceType":"module"}